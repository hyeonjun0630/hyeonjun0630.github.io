vscode들어가서 clone repository로 주소복사해서 가져오기
github 로그인하기
복제하기
터미널 열어서
git config --global user.email "hyeonjun@inha.edu"
git config --global user.name "hyeonjun0630"
치기.

10 42까지

[HTML 개념]

하이퍼텍스트
<a href=" ">nothing </a>
id 클릭하면 해당 아이디 따라가기
<a href="#id">id</a>
글자모양 태그
<b></b>, <i></i>, <small></small>, <sub></sub>, <sup></sup>, <ins></ins>, <del></del>

네비게이션 메뉴 순서없는 메뉴 = <ul></ul>
순서있는 메뉴 = <ol></ol>
목록 요소 추가 = <li></li> => ul, ol 내부에 집어넣기

테이블 표 만들기(table)
  표 삽입 = <table border="1"></table>
  표에 행 삽입 = <tr></tr>
  표에 제목 셀 삽입 = <th></th> (속성으로 colspan, rowspan 사용가능)
  표에 일반 셀 삽입 = <td></td> (셀의 너비, 셀의 높이지정.)
  구역 구분위해 <thead></thead>
  <tbody></tbody>
  <tfoot></tfoot> 사용 가능

이미지 삽입 = <img src="주소" alt="설명" width="너비" height="높이">
            = <img src="Nothing" alt="그림이 존재하지 않습니다.">
오디오 삽입 = <audio src="주소" controls="controls"></audio>
비디오 삽입 = <video controls="controls">
                <source src="주소" type="video/확장자">
              </video>
            = <video controls="controls">
                <source src="content_warning.webm" type="video/webm">
              </video>


입력 양식 = <form></form> 으로 영역생성, 내부에 input태그 넣어서 submit 제출버튼으로 데이터 전달
<form>
  <input type="text" name="search" />
  <input type="submit" />
</form>



입력양식 개요 = 전송방식으로 get, post 사용가능
                get은 주소창에 데이터가 노출되어 보안에 취약
                post는 데이터가 숨겨져서 보안에 강함
                action은 데이터를 전송할 주소, method는 데이터 전송방식
                <form action="주소" method="get/post">
                  <input type="text" name="search" />
                  <input type="submit" />
                </form>

입력양식 종류 = 글 입력류 = text, password, textarea,email, fieldset, legend, label
(강노68~69)     선택버튼류 = radio, checkbox, submit, reset, button, file, select, option
                기타 = hidden, date, month, week, time, datetime-local

[NOTE!]
  - label 태그의 for 속성에 input 태그의 id 속성을 입력해 input 태그를 설명할 수 있다.
    또한 label 태그(화면상의 "이름"부분 )를 클릭하면 input 태그(화면상의 "텍스트박스"부분)에 포커스.
  <form>
    <label for="name">이름</label>
    <input type="text" id="name" />
  </form>

  - radio 버튼은 name 속성을 같게 입력해야 여러 항목 중 하나만 선택됨
    <input id="man" type="radio" name="gender" value="m">
    <label for="man">남자</label>

    <input id="woman" type="radio" name="gender" value="w">
    <label for="woman">여자</label>

  - select 태그 = 목록의 항목 중 하나 또는 여러 개를 선택할 때 사용
    -> multiple 속성 = 여러 개 선택 가능
    option 태그 = select 태그 내부에 넣으면 옵션 선택 요소가 생성됨
    <select multiple="multiple">
      <option value="1">1</option>
      <option value="2">2</option>
    </select>

    optgroup태그를 사용해 선택 옵션을 그룹으로 묶을 수 있음. -> 강노참고

  - fieldset태그와 legend 태그로 입력 양식을 그룹으로 묶고 이름을 지정할 수 있다. -> 강노참고

  - textarea태그 내 들여쓰기가 입력 양식 내부에 출력되므로 주의!!!!
    <textarea>
      내용
      내용
    </textarea>가 아니라

    <textarea>내용
    내용</textarea>로 작성해야함
[NOTE!]

반응형 웹(460) = 웹사이트가 사용자의 화면 크기에 맞춰 자동으로 크기를 조절하는 것
반응형 웹패턴
==> 반응형 = 시험 엑스트라정도의 분량
[HTML 개념 끝]





[CSS 개념]

<link rel="stylesheet" href="style.css" /> 으로 외부 css 파일 불러올 수 있음.

선택자 (강노 90~107)
  전체 선택자      = * {속성:값;} => 모든 요소에 적용

  태그 선택자      = 태그명 {속성:값;} => 특정 태그에 적용

  아이디 선택자    = #아이디명 {속성:값;} => 특정 아이디에 적용

  클래스 선택자    = .클래스명 {속성:값;} => 특정 클래스에 적용

  후손 선택자      = 선택자 선택자 {속성:값;} => 선택자 하위의 모든 요소에 적용
                   = #header h1 {속성:값;} => header id를 가진 요소의 하위 h1 요소에 적용 (후손이어도 상관 없음)

  자손 선택자      = 선택자 > 선택자 {속성:값;} => 선택자의 자식 요소에 적용(후손X)
                   = #header > h1 {속성:값;} => header id를 가진 요소의 자식 h1 요소에 적용
                   [NOTE!!] table 태그에 스타일을 적용할 때는 자손 선택자를 사용하면 안 됨.
                   table > tr > th {속성:값;} => 이렇게 사용하면 안 됨.
                   table th {속성:값;}        => 이렇게 사용해야 함.

  반응 선택자      = 선택자:상태 {속성:값;} => 선택자의 상태에 따라 적용
                   = div:hover {color:red;} => div태그에 마우스를 올렸을 때 색상 변경
                   = div:active {color:red;} => div태그를 클릭했을 때 색상 변경

  속성 선택자      = 선택자[속성=값] {속성:값;} => 특정한 속성 내부 값이 특정 값과 일치할 때 적용
                   = input[type="text"] {속성:값;} => input 태그의 type이 text인 요소에 적용
                   [응용]
                    = input[type="text"]:focus {background-color: red;} => input 태그의 type이 text인 요소에 포커스가 맞춰졌을 때 색상 변경
                    = input[type="radio"]:checked + label {color: red;} => input 태그의 type이 radio인 요소가 체크되었을 때 label태그에 색상 변경


  상태 선택자      = 선택자:상태 {속성:값;} => 선택자의 상태에 따라 적용
                   = input:enabled {background-color: red;} => input태그가 활성화(사용 가능할때)되었을 때 색상 변경
                   = input:disabled {background-color: red;} => input태그가 비활성화(사용 불가능할때)되었을 때 색상 변경
                   = input:checked {background-color: red;} => input태그가 체크되었을 때 색상 변경
                   = input:focus {background-color: red;} => input태그에 포커스가 맞춰졌을 때 색상 변경

  구조 선택자      = 선택자:first-child {속성:값;} => 선택자의 형제 요소 중 첫 번째 요소에 적용
                           :last-child {속성:값;} => 선택자의 형제 요소 중 마지막 요소에 적용
                 중요!!!!! :nth-child(수열) {속성:값;} => 선택자의 형제 요소 중 (수열) 번째 요소에 적용(숫자도 가능)


  선택자를 함께 사용하여 정확한 요소를 선택할 수 있다. li.select {...} -> li태그 중 class가 select인 요소에 적용



크기단위
  px = 픽셀 단위, 고정크위
  em = 배수 단위, 부모요소의 크기에 따라 상대적으로 변함
  % = 백분율 단위, 부모요소의 크기에 따라 상대적으로 변함


색상단위
  rgb = rgb(0, 0, 0) ~ rgb(255, 255, 255)
  rgba = rgba(0, 0, 0, 0) ~ rgba(255, 255, 255, 1) (a = 투명도)


url단위
  이미지 위치에 따라 URL 경로를 다음 코드와 같이 입력해 파일에 접근.
  ex) background-image: url("경로/파일명.확장자");


Common Property Types
 Property Type의 Property => 강노 146
 ex) text-align, border-radius....



박스 속성 = width, height, margin, padding, border (154)
  - border 기준 안쪽   = padding
                바깥쪽 = margin

  - 마진 상쇄 = 두 요소의 마진이 겹칠 때 큰 마진만큼만 적용됨 (상하좌우 모두 적용됨)
              = 따라서 두 요소의 마진이 겹치지 않게 하려면 두 요소 사이에 border, padding을 넣어야 함.

  - border = border-width, border-style, border-color로 구성
           = border: 1px solid black; (순서대로 width, style, color)
           = border-radius: 10px; (모서리 둥글게 만들기)

  - overflow = 요소의 크기가 작아서 내용이 넘칠 때 처리 방법을 지정
             = visible(넘친 내용이 보임)
             = hidden (넘친 내용이 안 보임)
             = scroll (넘친 내용이 스크롤로 보임)
             = auto   (넘친 내용이 스크롤로 보임)

가시 속성 = display, visibility (177)
  - display = 요소의 표시 방법을 지정
            = none        (요소를 보이지 않게 함)
            = block       (요소를 블록 요소로 표시)
            = inline      (요소를 인라인 요소로 표시) = 따라서 width, height, margin, padding 속성 사용 불가능
            = inline-block(요소를 인라인 블록 요소, 블록과 인라인의 중간형태로 표시) = 위 속성 사용 가능

배경 속성 = background (184)
  - background = background-color: red;                       (배경색 지정)
               = background-image: url("경로/파일명.확장자"); (배경 이미지 지정)
               = background-repeat: no-repeat;                (배경 이미지 반복 방법 지정)
               = background-position: center;                 (배경 이미지 위치 지정)
               = background-attachment: fixed;                (배경 이미지 고정 여부 지정)
               = background-size: 100px 100px;                (배경 이미지 크기 지정)
               한번에 입력도 가능하긴 하다.



글자 속성 = font (190)
  - font = font-style: italic;          (글자 스타일 지정)
         = font-weight: bold;           (글자 두껍게 지정)
         = font-size: 20px;             (글자 크기 지정)
         = font-family: "맑은 고딕";    (글자 폰트 지정)
         = line-height: 1.5;            (줄 간격 지정)
         = text-decoration: underline;  (글자 밑줄 지정)
         = text-transform: uppercase;   (글자 대문자로 지정)
         = letter-spacing: 2px;         (글자 간격 지정)
         = word-spacing: 2px;           (단어 간격 지정)
         = text-indent: 20px;           (들여쓰기 지정)
         = white-space: nowrap;         (공백 처리 지정)
         = text-overflow: ellipsis;     (글자가 넘칠 때 처리 방법 지정)
         = overflow: hidden;            (넘친 내용 처리 방법 지정)
         = word-wrap: break-word;       (긴 단어 처리 방법 지정)
         = word-break: break-all;       (긴 단어 처리 방법 지정)
         = hyphens: auto;               (하이픈 처리 방법 지정)
  중요!! = text-align: center;          (글자 정렬 지정)
                     : justify;         justify는 "양쪽 정렬"로 마지막 줄을 제외한 모든 줄이 같은 길이로 맞춰짐
             <span class="font_center">Lorem ipsum dolor amet</span> -> inline이라 정렬이 안 렬
             <p class="font_center">Lorem ipsum dolor amet</p>       -> block이라 정렬이 됨


   - 글자 수직정렬하기 = 글자의 line-height와 글자를 감싸는 박스의 height를 같게 설정하면 수직정렬이 됨
     (216)             = line-height: 100px; height: 100px; => 수직정렬됨
                       = line-height: 100px; height: 50px; => 수직정렬 안 됨



위치속성 = position (220~226)(393~400)
  - position = static;          (기본값, 요소를 일반적인 문서 흐름에 따라 위에서 아래로 배치)
             = relative;        (초기 위치를 기준으로 상하좌우로 이동)
             = absolute;        (절대 위치로 좌표 설정)
             = fixed;           (스크롤과 상관없이 항상 문서 가장 좌측 상단을 기준으로 좌표를 설정한다.)
             = sticky;          (스크롤 위치에 따라 상하좌우로 이동)

  - top, right, bottom, left 속성을 사용해 위치를 지정
    ex) position: absolute; top: 10px; right: 10px; => 오른쪽 상단에 위로

  - z-index 속성을 사용해 요소의 쌓임 순서를 지정
    ex) z-index: 10; => z-index가 높을수록 위에 쌓정
    
  - 자식 요소의 위치를 부모 요소를 기준으로 움직이게 지정하려면 부모 요소에 position: relative;를 지정해야 함 (226)
    ex) 부모 요소에 position: relative; 자식 요소에 position: absolute; top: 10px; right: 10px; => 부모 요소를 기준으로 위치 지정
   

유동속성 = float = 그림을 글자처럼 취급하여 텍스트가 그림 주위로 흐르게 함
(227, 393) - float 속성을 사용해 요소를 좌우로 이동
            ex) float: left; => 왼쪽으로 이동     = 왼쪽부터 배치
                float: right; => 오른쪽으로 이동  = 오른쪽부터 배치


그림자 속성 = box-shadow, text-shadow (235)
            - box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5); => 그림자 효과 지정
            - text-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5); => 글자에 그림자 효과 지정



css layout(389) = 위치속성과 가시속성, 유동속성, css를 활용하여 꾸미기
                  => 위치속성(position) + 가시속성(visibility) + 유동속성(float) + css (hover)
                     작은 이미지에 마우스를 올리면 큰 이미지가 나타나는 효과 생성
                     강노 400 참고


                = 398페이지 new 배너 숨기기 예제. 자바스크립트 사용


Flex와 Grid(403)
  참고자료 : https://studiomeal.com/archives/197
  flex = Flex는 요소를 유연하게 배치하기 위한 레이아웃 시스템이다.
         Flex는 요소를 가로 또는 세로로 정렬하거나, 요소의 크기를 조절하거나, 요소의 순서를 변경하는 등의 다양한 레이아웃을 만들 수 있다.
         따라서 float로 세로 두 줄 레이아웃을 만들 때보다 훨씬 간단하게 만들 수 있다.
         Flex는 컨테이너와 아이템으로 구성되며, 컨테이너에 적용하는 속성과 아이템에 적용하는 속성이 있다.
       
        = .container {
            display: flex; => 컨테이너를 Flex 컨테이너로 지정
            fles-wrap: wrap; => 요소가 컨테이너를 벗어나면 다음 줄로 이동하라는 의미
          }
          .container div {
            flex: 1 1 100px; => flex-grow, flex-shrink, flex-basis 순서로 작성
          }                     flex-grow: 1; => 남은 공간이 있으면 늘려서 모두 차지하라는 의미
                                flex-shrink: 1; => 요소가 컨테이너보다 작을 때 요소를 줄이라는 의미
                                flex-basis: 100px; => 기본 크기를 100px로 지정
       
        = 방향 정렬 =
          flex-direction: row; => 요소를 왼쪽에서 오른쪽으로 정렬
          flex-direction: column; => 요소를 위에서 아래로 정렬

        = 가로정렬 = 
          justify-content: flex-start; => 요소를 왼쪽으로 정렬
          justify-content: flex-end; => 요소를 오른쪽으로 정렬
          justify-content: center; => 가로 중앙정렬
          justify-content: space-between; => 요소 사이의 간격을 최대로 설정

        = 세로정렬 =
          align-items: flex-start; => 요소를 위로 정렬
          align-items: flex-end; => 요소를 아래로 정렬
          align-items: center; => 세로로 중앙정렬
          align-items: space-between; => 요소 사이의 간격을 최대로 설정

        = 아이템 중앙 정렬 = (410)
          align-items: center; => 세로 가운데 정렬
          justify-content: center; => 가로 가운데 정렬
        
        = 활용 =
          - 카드 레이아웃 (412)
          - 네비게이비션 바 (411)

  grid = Grid는 2차원(가로-세로) 레이아웃 시스템이다.
       = Flex와 비슷하지만 Flex는 1차원 레이아웃 시스템이고(가로만, 세로만)
         Grid는 2차원 레이아웃 시스템이다. (가로 세로 동시)

       = .container {
           display: grid; => 컨테이너를 Grid 컨테이너로 지정
           grid-template-columns: repeat(3, 1fr); => 3개의 열을 시성하고 각 열의 너비를 균등하게 나눔
          }                                          : grid-template-columns: 1fr 1fr 1fr;와 같음
         .container div {
           grid-area: header; => 템플릿 영역을 지정
         }
      
       = gap 속성을 사용해 각 셀 사이의 간격을 지정할 수 있다.
         .container {
           gap: 10px; => 각 셀 사이의 간격을 10px로 지정
         }

       = 정렬 방법
         - justify-items: center; => 가로 정렬
         - align-items: center; => 세로 정렬
         420~421페이지 참고

       = 화상키보드, nested grids(422) 등 활용 가능


수평 정렬 레이아웃(426~431) = 자손에게 float, 부모의 overflow 속성에 hidden 키워드 사용
중앙 정렬 레이아웃(432~435) = 중앙 정렬할 태그에 width 속성을 부여하고 margin 속성을 ‘0 auto’로 입력.
One True 정렬 레이아웃(436~441) = ①부모 태그에 고정된 너비를 지정.
                                  ②수평 정렬하는 부모 태그의 overflow 속성에 hidden을 적용.
                                  ③자손 태그에 적당한 너비를 입력하고 float 속성을 적용.


요소배치 = 부모기준 절대위치(absolute) = 부모 relative, 자식 absolute하면 부모 위를 기준삼아 자식이동.
         = 중앙배치 = 중앙 정렬하려는 div 태그의 position 속성을 absolute로 지정.
                      left 속성과 top 속성을 모두 50%로 지정.
                      중앙에 정렬하려는 div 태그의 margin-left 속성과 margin-top 속성에 음수를 입력.
         = 고정배치 = 고정하려는 태그의 position 속성을 fixed로 지정하고 고정시키고 싶은 위치에 top, left 등을 0으로 지정


글자 생략 = text-overflow: ellipsis;  => 글자가 넘칠 때 생략 부호(...)를 표시
(457)       white-space: nowrap;      => 글자가 넘칠 때 줄바꿈을 하지 않고 한 줄로 표시
            overflow: hidden;         => 넘친 글자를 숨김
            width: 100px;             => 너비를 100px로 지정

[CSS 개념 끝]








[JavaScript 개념] (248)

C와는 다르게 함수도 객체로 취급됨
따라서 함수를 변수에 할당하거나 함수를 다른 함수의 인수로 전달할 수 있음.

<script src="script.js"></script> 으로 외부 js 파일 불러올 수 있음.

css와는 다르게 변수명에 -를 사용할 수 없으며 대소문자를 구분함.
따라서 변수명에 카멜케이스를 사용함.

동적 타입 언어이기 때문에 변수의 타입을 선언하지 않아도 됨.
그러나 변수라는 것을 알려주기 위한 키워드는 존재함.
  [키워드]
    - var
    기본적으로 JS에서 변수선언하는 키워드.
    함수 범위 변수 선언을 가능하게 함.
    원래 이것만 존재했으나, 중복선언이 가능하며, 예기치 못한 값을 반환할 수 있는 문제,
    함수 외부에서 선언한 변수는 모두 전역변수가 되어버리는 문제,
    변수 선언문 이전에 변수를 참조하게되면 언제나 undifined를 반환하는 문제가 발생하여
    밑의 let, const로 문제를 해결했다.
    
    - let
    블록 범위 지역 변수 선언을 가능하게 함.
    중복선언 불가능. 그러나 재할당은 가능하다. 선언과 초기화를 따로 해도 상관없다.
    
    - const
    블록 범위 상수 선언을 가능하게 함.
    선언과 초기화가 동시에 이루어져야하며, 재할당도 불가능하다.
    
변수 선언 방법
  - var 변수명 = 값; => 변수 선언 및 초기화
  - var 변수명; => 변수 선언
  - 변수명 = 값; => 변수 초기화

메소드
  alert() = 경고창을 띄움                 => alert("Hello World!");
  prompt() = 사용자에게 입력창을 띄움     => let answer = prompt("이름을 입력하세요.");
  confirm() = 사용자에게 확인창을 띄움    => let answer = confirm("정말로 삭제하시겠습니까?");
  console.log() = 콘솔에 출력함           => console.log("Hello World!");
  document.write() = 문서에 출력함        => document.write("Hello World!");


데이터 타입
  - 레퍼런스 타입 = 객체를 가리키기 위한 타입 (포인터처럼 동작)
  - primitive 타입 = 단순히 타입만 가지고 있는, 객체가 아닌 데이터를 위한 타입
    = boolen, null, undefined, number, string
  
  ex) let x = 10;          => x는 primitive number 타입
      let y = "Hello";     => y는 primitive string 타입
      
      let z = y;           => z는 reference string 타입
      let foo = [1, 2, 3]; => foo는 reference 배열 타입
      let bar = foo;       => bar는 reference 배열 타입


빌트인 객체
  - 빌트인 객체 = 자바스크립트에서 기본적으로 제공하는 객체
  - 빌트인 객체 종류 = Date, Math, String, Number, Boolean, Object, Function, DataView 등
      let date = new Date(); => 현재 날짜와 시간을 반환
      let abd = date.toString(); => 날짜와 시간을 문자열로 반환

      let math = Math.PI;    => 원주율을 반환


concatenation = 문자열을 합치는 것
  - 문자열 합치기 = 문자열 + 문자열
  - 문자열과 변수 합치기 = 문자열 + 변수
  - 문자열과 변수 합치기 = `문자열 ${변수}`

  ex) let name = "홍길동";
      let age = 20;
      let message = `안녕하세요. 제 이름은 ${name}이고, 나이는 ${age}살 입니다.`;
      console.log(message); => 안녕하세요. 제 이름은 홍길동이고, 나이는 20살 입니다.


자료형(273)

조건문(287)
  - 주의할 연산자: ==, ===, !=, !==
    == : 값만 비교         => (x == 9 ture | x == "9" true)
    === : 값과 타입 비교   => (x === 9 false | x === "9" true)
    != : 값만 비교         => (x != 9 false | x != "9" false)
    !== : 값과 타입 비교   => (x !== 9 true | x !== "9" false)


루프문(292)
  for 루프 활용
  - for in 루프 = 객체의 속성을 반복 => for (let key in object) {console.log(key);}
  - for of 루프 = 배열의 요소를 반복 
   => for (let value of years) {    =    for (let i = 0; i < array.length; i++) {
        console.log(value);                let yr = years[i];
      }                                    console.log(yr); }


배열(318)
  - 배열 선언 방법
    - 키워드 배열명 = [요소1, 요소2, 요소3];
    - 키워드 배열명 = new Array(요소1, 요소2, 요소3);
    - 키워드 배열명 = new Array(3); => 3개의 요소를 가진 배열 생성

  - 배열 요소 접근 방법
    - 배열명[인덱스] = 요소값
    - 배열명.length = 배열의 길이

  - 배열 메소드
    - 배열명.push(요소) = 배열의 끝에 요소 추가
    - 배열명.pop() = 배열의 끝 요소 제거
    - 배열명.shift() = 배열의 첫 요소 제거
    등등

  - 스프레드 연산자 = 배열을 복사하거나 합칠 때 사용
    - let arr1 = [1, 2, 3];
      let arr2 = [...arr1]; => arr1을 복사하여 arr2에 저장
      let arr3 = [...arr1, 4, 5]; => arr1에 4, 5를 추가하여 arr3에 저장


객체(327)
  - 객체 선언 방법 (약간 배열과 비슷함)
    - 키워드 객체명 = {키:값, 키:값, 키:값};
      const objName = {
        key1: value1,
        key2: value2,
        key3: value3
      };
    
    - 키워드 객체명 = new Object();
      const objName = new Object(); => 빈 객체 생성

      const objName = {}; => 빈 객체 생성

    - let hello = new String("Hello World!"); => 문자열 객체 생성
      let num = new Number(10); => 숫자 객체 생성
      let bool = new Boolean(true); => 불리언 객체 생성
    
    - 객체 내부에 객체 생성 가능. 배열도 가능. (333)


  - 객체 개요, 속성 접근 방법(~347)
    - 객체명.키
    - 객체명["키"]
    - 반복문 접근법
      for (let key in obj) {
        console.log(key, obj[key]);
      }


함수(349)
  - 함수 선언 방법
    - 함수 선언식 = function 함수명(매개변수) {함수 내용}
    - 함수 표현식 = var 함수명 = function(매개변수) {함수 내용}
    - 화살표 함수 = var 함수명 = (매개변수) => {함수 내용}

    - 함수 선언식 (Function Declarations)
      function 함수() {
        return "이것은 선언적 함수입니다.";
      }

      let 함수 = function() {
        return "이것은 익명 함수입니다.";
      }
      
    - 함수 표현식 (Function Expressions)
      자바스크립트 함수는 표현식을 사용하여 정의 될 수 있으며, 함수 표현식은 변수로 저장될수 있다.
      e.g. ) `var x = function (a, b) {return a * b};`
     명
      함수 표현식이 변수에 저장되면, 변수는 함수처럼 사용 가능해진다.
      변수에 저장된 함수는 함수명이 필요 없으며, 변수 이름을 통하여 호출된다.(Anonymous Functions)


  - 함수 자체가 객체라 ()를 붙이지 않으면 함수 내용이 출력됨
    - 함수명(); => 함수 호출
    - 함수명; => 함수 내용 출력

    const foo = function() {
      return "Hello World!";
    };
    alert(foo); => 함수 내용 출력
    alert(foo()); => 함수 호출

  - 함수 매개변수 초기값 지정가능
    - function foo(a = 10, b = 20) {
        return a + b;
      }
      console.log(foo()); => 30
      console.log(foo(5)); => 25
      console.log(foo(5, 5)); => 10

  - rest operator = 함수의 매개변수로 전달된 인수를 배열로 받을 수 있음
    - function foo(...args) {
        return args;
      }
      console.log(foo(1, 2, 3, 4, 5)); => [1, 2, 3, 4, 5]

  - nested function = 함수 내부에 함수를 선언할 수 있음
    - function foo() {
        function bar() {
          return "Hello World!";
        }
        return bar();
      }
      console.log(foo()); => Hello World!


  - 콜백 함수 = 함수의 매개변수로 전달되는 함수
    function callTenTimes(callback) {
      for (let i = 0; i < 10; i++) {
        callback();
      }
    }
    
    let fun=function () {                 or    callTenTimes(function() {
      alert('함수 호출');                         alert('팝업 호출');
    };                                          });

    callTenTimes(fun); => 팝업 10번 호출


돔, Document(494) = 문서 객체: HTML 태그를 자바스크립트에서 사용할 수 있는 객체로 만든 것.
  - 사용법 = 헤드에 넣어쓰기
              <script>
                window.onload = function() {
                  // 자바스크립트 코드
                };
              </script>
            = 바디에 넣어쓰기
              <body>
               본문
                <script> // 마지막에 넣어쓰기
                // 자바스크립트 코드
                </script>
              </body>

  - 돔 접근 방법
    - selction method (한글 설명 = 557페이지 참고)
      - document.getElementById("id"); => id로 요소를 찾음
      - document.getElementsByClassName("class"); => class로 요소를 찾음
      - document.getElementsByTagName("tag"); => 태그로 요소를 찾음
      - document.querySelector("css"); => css 선택자로 해당 선택자를 쓰는 첫번째 요소를 찾음
      - document.querySelectorAll("css"); => css 선택자로 요소를 모두 찾음
        ex) querySelector("#main div time"); => id가 main인 요소의 자식 div 요소의 첫번째 time 요소를 찾음
            querySelectorAll("#main div time"); => id가 main인 요소의 자식 div 요소의 모든 time 요소를 찾음

  - 요소
    ex) let element = document.getElementById("id");
        element.innerHTML = "Hello World!"; => 요소 내용 변경

  - 돔 조작 방법(505)
    - 요소.innerHTML = "내용"; => 요소 내용 변경    (태그 포함, html내부 내용을 변경)
    - 요소.textContent = "내용"; => 요소 내용 변경  (태그 미포함, 문자열만 변경)
    - 요소.style.속성 = "값"; => 요소 스타일 변경   (js에선 카멜케이스로 작성)
    - 요소.addEventListener("이벤트", 함수); => 이벤트 추가
    - 요소.removeEventListner("이벤트", 함수); => 이벤트 제거
      => 회원가입 유효성검사 예제 참고(582페이지)

    ex 1)
    <script>
      // 이벤트를 연결합니다.
      window.onload = function () {
        // 변수를 선언합니다.
        let output = '';
        for (let i = 0; i < 10; i++) {
          output += '<h1>Header - ' + i + '</h1>';
        }
        // 문서 객체 내부의 글자를 변경합니다. 따라서 html 전문을 순수 텍스트로 가져옴
        document.body.textContent = output;
        // innerHTML 속성을 사용합니다. 따라서 html을 수정함, 바뀐 내용이 html로 출력됨
        document.body.innerHTML = output;
      };
    </script>

    ex 2)
    const node = document.getElementbyId("id");

    node.innerHTML = "Hello World!";
    node.style.backgroundColor = "red";
    node.addEventListener("click", function() {
      alert("Hello World!");
    });


  - 이벤트 = 사용자의 동작에 의해 발생하는 것 (513)
    - 마우스 이벤트 = click, dblclick, mouseover, mouseout, mousedown, mouseup, mousemove
    - 키보드 이벤트 = keydown, keyup, keypress
    - 입력 이벤트 = focus, blur, change, input
    - 윈도우 이벤트 = load, resize, scroll, unload
    - 폼 이벤트 = submit, reset, change, select
    - 기타 이벤트 = error, select, contextmenu

    ex)
        <script>
        document.getElementById("key").addEventListener("keydown",
          function (e) {
            let keyPressed=e.key;
            let character=String.fromCharCode(keyPressed);
            alert("Key " + character + " was pressed");
        });

        document.querySelector("#loginForm").addEventListener("submit",
          function (e) {
            let pass = document.querySelector("#pw").value;
            if (pass=="") {
              alert ("enter a password");
              e.preventDefault();
          }
        });
        </script>
    
    - 요소.addEventListener("이벤트", 함수); => 이벤트 추가
    - 아래 세 코드는 같은 기능을 함

      const btn = document.getElementById("btn");     => id가 btn인 요소를 찾음
      btn.addEventListener("click", function() {      => 클릭했을 때 이벤트 발생
        alert("Hello World!");                        => Hello World! 출력
      });
      --------------------------------------------------------------------------
      document.querySelector("#btn").addEventListener("click", function() { => id가 btn인 요소 중 첫번째를 찾아서 클릭했을 때 이벤트 발생
        alert("Hello World!");
      });
      --------------------------------------------------------------------------
      document.querySelector("#btn").addEventListener("click", () => {      => 화살표 함수로도 가능
        alert("Hello World!");
      });


    - 아쉽게도 리스트에는 addEventListener가 없음 (516)
      따라서 for문을 사용하여 각 요소에 이벤트를 추가해야 함
      ex) const btns = document.querySelectorAll("#list button");
          for (let i = 0; i < list.length; i++) {               or   for(let bt of btns) {
            list[i].addEventListener("click", function() {            bt.addEventListener("click", function() {
              alert("Hello World!");                                    alert("Hello World!");
            });                                                      });

    
    - 인라인 이벤트 = HTML 요소에 직접 이벤트를 추가하는 방법
      [in HTML]
      - <button onclick="alert('Hello World!')">Click Me</button>
      - <button onmousemove="alert('Hello World!')">Mouse Move</button>
      [in head + body]
      - <script>
          function hello() {
            alert("Hello World!");
          }
        </script>
        <body>
          <button onclick="hello()">Click Me</button>
        </body>


    - 이벤트 객체 e = 이벤트가 발생했을 때 이벤트에 대한 정보를 가지고 있는 객체
      - 이벤트 객체의 속성
        - type = 이벤트 타입
        - target = 이벤트가 발생한 요소
        - clientX, clientY = 브라우저 창을 기준으로 마우스의 x, y 좌표
        등등

      - 이벤트 객체 사용 방법
        - 요소.addEventListener("이벤트", function(e) {함수});
        - 요소.addEventListener("이벤트", (e) => {함수});

        ex) const btn = document.getElementById("btn");
            btn.addEventListener("click", function(e) {
              console.log(e.target); => 이벤트가 발생한 요소 출력
            });

            btn.addEventListener("click", (e) => {
              console.log(e.target); => 이벤트가 발생한 요소 출력
            });

        ex) 메뉴 선택시 해당 메뉴 토글하기 = 520페이지 참고


    - 이벤트 전파 = 이벤트가 발생한 요소에서 상위 요소로 전파되는 것 (523~525)
      - 이벤트 전파 방지 = 이벤트가 발생한 요소에서 상위 요소로 전파되는 것을 막음
    

    - 이벤트 위임 = 하위 요소에 각각 이벤트를 추가하는 것이 아닌 상위 요소에 이벤트를 추가하여 하위 요소의 이벤트를 관리하는 방법
      - 이벤트 위임 방법
        - 상위 요소에 이벤트를 추가
        - 이벤트 객체의 target 속성을 사용하여 이벤트가 발생한 요소를 찾음

      - 이벤트 위임 예시
        - const list = document.getElementById("list");
          list.addEventListener("click", function(e) {
            if (e.target.tagName === "LI") {
              e.target.classList.toggle("checked");
            }
          });

        - 위 코드는 리스트 요소를 클릭했을 때 checked 클래스를 토글하는 코드
        - 이벤트 위임을 사용하면 리스트 요소가 추가되어도 이벤트를 추가할 필요가 없음
[JavaScript 개념 끝]