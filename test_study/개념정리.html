<!-- vscode들어가서 clone repository로 주소복사해서 가져오기
github 로그인하기
복제하기
터미널 열어서
git config --global user.email "hyeonjun@inha.edu"
git config --global user.name "hyeonjun0630"
치기.



[HTML 개념]

하이퍼텍스트
<a href=" ">nothing </a>
id 클릭하면 해당 아이디 따라가기
<a href="#id">id</a>
글자모양 태그
<b></b>, <i></i>, <small></small>, <sub></sub>, <sup></sup>, <ins></ins>, <del></del>

네비게이션 메뉴 순서없는 메뉴 = <ul></ul>
순서있는 메뉴 = <ol></ol>
목록 요소 추가 = <li></li> => ul, ol 내부에 집어넣기

테이블 표 만들기(table)
  표 삽입 = <table border="1"></table>
  표에 행 삽입 = <tr></tr>
  표에 제목 셀 삽입 = <th></th> (속성으로 colspan, rowspan 사용가능)
  표에 일반 셀 삽입 = <td></td> (셀의 너비, 셀의 높이지정.)
  구역 구분위해 <thead></thead>
  <tbody></tbody>
  <tfoot></tfoot> 사용 가능

이미지 삽입 = <img src="주소" alt="설명" width="너비" height="높이">
            = <img src="Nothing" alt="그림이 존재하지 않습니다.">
오디오 삽입 = <audio src="주소" controls="controls"></audio>
비디오 삽입 = <video controls="controls">
                <source src="주소" type="video/확장자">
              </video>
            = <video controls="controls">
                <source src="content_warning.webm" type="video/webm">
              </video>


입력 양식 = <form></form> 으로 영역생성, 내부에 input태그 넣어서 submit 제출버튼으로 데이터 전달
<form>
  <input type="text" name="search" />
  <input type="submit" />
</form>

입력양식 개요 = 전송방식으로 get, post 사용가능
                get은 주소창에 데이터가 노출되어 보안에 취약
                post는 데이터가 숨겨져서 보안에 강함
                action은 데이터를 전송할 주소, method는 데이터 전송방식
                <form action="주소" method="get/post">
                  <input type="text" name="search" />
                  <input type="submit" />
                </form>

입력양식 종류 = 글 입력류 = text, password, textarea,email, fieldset, legend, label
(강노68~69)     선택버튼류 = radio, checkbox, submit, reset, button, file, select, option
                기타 = hidden, date, month, week, time, datetime-local

[NOTE!]
  - label 태그의 for 속성에 input 태그의 id 속성을 입력해 input 태그를 설명할 수 있다.
    또한 label 태그(화면상의 "이름"부분 )를 클릭하면 input 태그(화면상의 "텍스트박스"부분)에 포커스.
  <form>
    <label for="name">이름</label>
    <input type="text" id="name" />
  </form>

  - radio 버튼은 name 속성을 같게 입력해야 여러 항목 중 하나만 선택됨
    <input id="man" type="radio" name="gender" value="m">
    <label for="man">남자</label>

    <input id="woman" type="radio" name="gender" value="w">
    <label for="woman">여자</label>

  - select 태그 = 목록의 항목 중 하나 또는 여러 개를 선택할 때 사용
    -> multiple 속성 = 여러 개 선택 가능
    option 태그 = select 태그 내부에 넣으면 옵션 선택 요소가 생성됨
    <select multiple="multiple">
      <option value="1">1</option>
      <option value="2">2</option>
    </select>

    optgroup태그를 사용해 선택 옵션을 그룹으로 묶을 수 있음. -> 강노참고

  - fieldset태그와 legend 태그로 입력 양식을 그룹으로 묶고 이름을 지정할 수 있다. -> 강노참고

  - textarea태그 내 들여쓰기가 입력 양식 내부에 출력되므로 주의!!!!
    <textarea>
      내용
      내용
    </textarea>가 아니라

    <textarea>내용
    내용</textarea>로 작성해야함
[NOTE!]
[HTML 개념 끝]




[CSS 개념]

<link rel="stylesheet" href="style.css" /> 으로 외부 css 파일 불러올 수 있음.

선택자 (강노 90~107)
  전체 선택자      = * {속성:값;} => 모든 요소에 적용

  태그 선택자      = 태그명 {속성:값;} => 특정 태그에 적용

  아이디 선택자    = #아이디명 {속성:값;} => 특정 아이디에 적용

  클래스 선택자    = .클래스명 {속성:값;} => 특정 클래스에 적용

  후손 선택자      = 선택자 선택자 {속성:값;} => 선택자 하위의 모든 요소에 적용
                   = #header h1 {속성:값;} => header id를 가진 요소의 하위 h1 요소에 적용 (후손이어도 상관 없음)

  자손 선택자      = 선택자 > 선택자 {속성:값;} => 선택자의 자식 요소에 적용(후손X)
                   = #header > h1 {속성:값;} => header id를 가진 요소의 자식 h1 요소에 적용
                   [NOTE!!] table 태그에 스타일을 적용할 때는 자손 선택자를 사용하면 안 됨.
                   table > tr > th {속성:값;} => 이렇게 사용하면 안 됨.
                   table th {속성:값;}        => 이렇게 사용해야 함.

  반응 선택자      = 선택자:상태 {속성:값;} => 선택자의 상태에 따라 적용
                   = div:hover {color:red;} => div태그에 마우스를 올렸을 때 색상 변경
                   = div:active {color:red;} => div태그를 클릭했을 때 색상 변경

  속성 선택자      = 선택자[속성=값] {속성:값;} => 특정한 속성 내부 값이 특정 값과 일치할 때 적용
                   = input[type="text"] {속성:값;} => input 태그의 type이 text인 요소에 적용
                   [응용]
                    = input[type="text"]:focus {background-color: red;} => input 태그의 type이 text인 요소에 포커스가 맞춰졌을 때 색상 변경
                    = input[type="radio"]:checked + label {color: red;} => input 태그의 type이 radio인 요소가 체크되었을 때 label태그에 색상 변경


  상태 선택자      = 선택자:상태 {속성:값;} => 선택자의 상태에 따라 적용
                   = input:enabled {background-color: red;} => input태그가 활성화(사용 가능할때)되었을 때 색상 변경
                   = input:disabled {background-color: red;} => input태그가 비활성화(사용 불가능할때)되었을 때 색상 변경
                   = input:checked {background-color: red;} => input태그가 체크되었을 때 색상 변경
                   = input:focus {background-color: red;} => input태그에 포커스가 맞춰졌을 때 색상 변경

  구조 선택자      = 선택자:first-child {속성:값;} => 선택자의 형제 요소 중 첫 번째 요소에 적용
                           :last-child {속성:값;} => 선택자의 형제 요소 중 마지막 요소에 적용
                 중요!!!!! :nth-child(수열) {속성:값;} => 선택자의 형제 요소 중 (수열) 번째 요소에 적용(숫자도 가능)


  선택자를 함께 사용하여 정확한 요소를 선택할 수 있다. li.select {...} -> li태그 중 class가 select인 요소에 적용



크기단위
  px = 픽셀 단위, 고정크위
  em = 배수 단위, 부모요소의 크기에 따라 상대적으로 변함
  % = 백분율 단위, 부모요소의 크기에 따라 상대적으로 변함


색상단위
  rgb = rgb(0, 0, 0) ~ rgb(255, 255, 255)
  rgba = rgba(0, 0, 0, 0) ~ rgba(255, 255, 255, 1) (a = 투명도)


url단위
  이미지 위치에 따라 URL 경로를 다음 코드와 같이 입력해 파일에 접근.
  ex) background-image: url("경로/파일명.확장자");


Common Property Types
 Property Type의 Property => 강노 146
 ex) text-align, border-radius....



박스 속성 = width, height, margin, padding, border (154)
  - border 기준 안쪽   = padding
                바깥쪽 = margin

  - 마진 상쇄 = 두 요소의 마진이 겹칠 때 큰 마진만큼만 적용됨 (상하좌우 모두 적용됨)
              = 따라서 두 요소의 마진이 겹치지 않게 하려면 두 요소 사이에 border, padding을 넣어야 함.

  - border = border-width, border-style, border-color로 구성
           = border: 1px solid black; (순서대로 width, style, color)
           = border-radius: 10px; (모서리 둥글게 만들기)

  - overflow = 요소의 크기가 작아서 내용이 넘칠 때 처리 방법을 지정
             = visible(넘친 내용이 보임)
             = hidden (넘친 내용이 안 보임)
             = scroll (넘친 내용이 스크롤로 보임)
             = auto   (넘친 내용이 스크롤로 보임)

가시 속성 = display, visibility (177)
  - display = 요소의 표시 방법을 지정
            = none        (요소를 보이지 않게 함)
            = block       (요소를 블록 요소로 표시)
            = inline      (요소를 인라인 요소로 표시) = 따라서 width, height, margin, padding 속성 사용 불가능
            = inline-block(요소를 인라인 블록 요소, 블록과 인라인의 중간형태로 표시) = 위 속성 사용 가능

배경 속성 = background (184)
  - background = background-color: red;                       (배경색 지정)
               = background-image: url("경로/파일명.확장자"); (배경 이미지 지정)
               = background-repeat: no-repeat;                (배경 이미지 반복 방법 지정)
               = background-position: center;                 (배경 이미지 위치 지정)
               = background-attachment: fixed;                (배경 이미지 고정 여부 지정)
               = background-size: 100px 100px;                (배경 이미지 크기 지정)
               한번에 입력도 가능하긴 하다.



글자 속성 = font (190)
  - font = font-style: italic;          (글자 스타일 지정)
         = font-weight: bold;           (글자 두껍게 지정)
         = font-size: 20px;             (글자 크기 지정)
         = font-family: "맑은 고딕";    (글자 폰트 지정)
         = line-height: 1.5;            (줄 간격 지정)
         = text-decoration: underline;  (글자 밑줄 지정)
         = text-transform: uppercase;   (글자 대문자로 지정)
         = letter-spacing: 2px;         (글자 간격 지정)
         = word-spacing: 2px;           (단어 간격 지정)
         = text-indent: 20px;           (들여쓰기 지정)
         = white-space: nowrap;         (공백 처리 지정)
         = text-overflow: ellipsis;     (글자가 넘칠 때 처리 방법 지정)
         = overflow: hidden;            (넘친 내용 처리 방법 지정)
         = word-wrap: break-word;       (긴 단어 처리 방법 지정)
         = word-break: break-all;       (긴 단어 처리 방법 지정)
         = hyphens: auto;               (하이픈 처리 방법 지정)
  중요!! = text-align: center;          (글자 정렬 지정)
                     : justify;         justify는 "양쪽 정렬"로 마지막 줄을 제외한 모든 줄이 같은 길이로 맞춰짐
             <span class="font_center">Lorem ipsum dolor amet</span> -> inline이라 정렬이 안 렬
             <p class="font_center">Lorem ipsum dolor amet</p>       -> block이라 정렬이 됨


   - 글자 수직정렬하기 = 글자의 line-height와 글자를 감싸는 박스의 height를 같게 설정하면 수직정렬이 됨
     (216)             = line-height: 100px; height: 100px; => 수직정렬됨
                       = line-height: 100px; height: 50px; => 수직정렬 안 됨



위치속성 = position (220)
  - position = static;          (기본값, 요소를 일반적인 문서 흐름에 따라 위에서 아래로 배치)
             = relative;        (초기 위치를 기준으로 상하좌우로 이동)
             = absolute;        (절대 위치로 좌표 설정)
             = fixed;           (스크롤과 상관없이 항상 문서 가장 좌측 상단을 기준으로 좌표를 설정한다.)

  - top, right, bottom, left 속성을 사용해 위치를 지정
    ex) position: absolute; top: 10px; right: 10px; => 오른쪽 상단에 위로

  - z-index 속성을 사용해 요소의 쌓임 순서를 지정
    ex) z-index: 10; => z-index가 높을수록 위에 쌓정
    
  - 자식 요소의 위치를 부모 요소를 기준으로 움직이게 지정하려면 부모 요소에 position: relative;를 지정해야 함 (226)
    ex) 부모 요소에 position: relative; 자식 요소에 position: absolute; top: 10px; right: 10px; => 부모 요소를 기준으로 위치 지정
    
유동속성 = float = 그림을 글자처럼 취급하여 텍스트가 그림 주위로 흐르게 함
          - float 속성을 사용해 요소를 좌우로 이동
            ex) float: left; => 왼쪽으로 이동     = 왼쪽부터 배치
                float: right; => 오른쪽으로 이동  = 오른쪽부터 배치


그림자 속성 = box-shadow, text-shadow (235)
            - box-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5); => 그림자 효과 지정
            - text-shadow: 10px 10px 10px rgba(0, 0, 0, 0.5); => 글자에 그림자 효과 지정





css layout = 





flex
하나의 아이템이 자신의 컨테이너(블록)가 차지하는 공간에 맞추기 위해
크기를 키우거나 줄이는 방법을 설정하는 속성이다.
Flex가 나오기 전에는 float: left, float: right 등으로 다소 까다롭게 레이아웃을 배치해야했었다.
속성으론 컨테이너에 적용하는 속성과 아이템에 적용하는 속성이 있다.

grid
기본적으로 Flex와 비슷하지만 Flex와의 큰 차이점은
- Flex는 한 방향 레이아웃 시스템이고 (1차원)
- Grid는 두 방향(가로-세로) 레이아웃 시스템 (2차원)
이다. 따라서 Flex보다 더 복잡하고, 복합적인 레이아웃을 만들 수 있다.







[CSS 개념 끝]



[JavaScript 개념] (248)

C와는 다르게 함수도 객체로 취급됨
따라서 함수를 변수에 할당하거나 함수를 다른 함수의 인수로 전달할 수 있음.

<script src="script.js"></script> 으로 외부 js 파일 불러올 수 있음.

css와는 다르게 변수명에 -를 사용할 수 없으며 대소문자를 구분함.
따라서 변수명에 카멜케이스를 사용함.

동적 타입 언어이기 때문에 변수의 타입을 선언하지 않아도 됨.
그러나 변수라는 것을 알려주기 위한 키워드는 존재함.
  [키워드]
    - var
    기본적으로 JS에서 변수선언하는 키워드.
    함수 범위 변수 선언을 가능하게 함.
    원래 이것만 존재했으나, 중복선언이 가능하며, 예기치 못한 값을 반환할 수 있는 문제,
    함수 외부에서 선언한 변수는 모두 전역변수가 되어버리는 문제,
    변수 선언문 이전에 변수를 참조하게되면 언제나 undifined를 반환하는 문제가 발생하여
    밑의 let, const로 문제를 해결했다.
    
    - let
    블록 범위 지역 변수 선언을 가능하게 함.
    중복선언 불가능. 그러나 재할당은 가능하다. 선언과 초기화를 따로 해도 상관없다.
    
    - const
    블록 범위 상수 선언을 가능하게 함.
    선언과 초기화가 동시에 이루어져야하며, 재할당도 불가능하다.
    
변수 선언 방법
  - var 변수명 = 값; => 변수 선언 및 초기화
  - var 변수명; => 변수 선언
  - 변수명 = 값; => 변수 초기화

메소드
  alert() = 경고창을 띄움                 => alert("Hello World!");
  prompt() = 사용자에게 입력창을 띄움     => let answer = prompt("이름을 입력하세요.");
  confirm() = 사용자에게 확인창을 띄움    => let answer = confirm("정말로 삭제하시겠습니까?");
  console.log() = 콘솔에 출력함           => console.log("Hello World!");
  document.write() = 문서에 출력함        => document.write("Hello World!");


데이터 타입
  - 레퍼런스 타입 = 객체를 가리키기 위한 타입 (포인터처럼 동작)
  - primitive 타입 = 단순히 타입만 가지고 있는, 객체가 아닌 데이터를 위한 타입
    = boolen, null, undefined, number, string
  
  ex) let x = 10;          => x는 primitive number 타입
      let y = "Hello";     => y는 primitive string 타입
      
      let z = y;           => z는 reference string 타입
      let foo = [1, 2, 3]; => foo는 reference 배열 타입
      let bar = foo;       => bar는 reference 배열 타입


빌트인 객체
  - 빌트인 객체 = 자바스크립트에서 기본적으로 제공하는 객체
  - 빌트인 객체 종류 = Date, Math, String, Number, Boolean, Object, Function, DataView 등
      let date = new Date(); => 현재 날짜와 시간을 반환
      let abd = date.toString(); => 날짜와 시간을 문자열로 반환

      let math = Math.PI;    => 원주율을 반환


concatenation = 문자열을 합치는 것
  - 문자열 합치기 = 문자열 + 문자열
  - 문자열과 변수 합치기 = 문자열 + 변수
  - 문자열과 변수 합치기 = `문자열 ${변수}`

  ex) let name = "홍길동";
      let age = 20;
      let message = `안녕하세요. 제 이름은 ${name}이고, 나이는 ${age}살 입니다.`;
      console.log(message); => 안녕하세요. 제 이름은 홍길동이고, 나이는 20살 입니다.


자료형(273)

조건문(287)
  - 주의할 연산자: ==, ===, !=, !==
    == : 값만 비교         => (x == 9 ture | x == "9" true)
    === : 값과 타입 비교   => (x === 9 false | x === "9" true)
    != : 값만 비교         => (x != 9 false | x != "9" false)
    !== : 값과 타입 비교   => (x !== 9 true | x !== "9" false)


루프문(292)
  for 루프 활용
  - for in 루프 = 객체의 속성을 반복 => for (let key in object) {console.log(key);}
  - for of 루프 = 배열의 요소를 반복 
   => for (let value of years) {    =    for (let i = 0; i < array.length; i++) {
        console.log(value);                let yr = years[i];
      }                                    console.log(yr); }


배열(318)
  - 배열 선언 방법
    - 키워드 배열명 = [요소1, 요소2, 요소3];
    - 키워드 배열명 = new Array(요소1, 요소2, 요소3);
    - 키워드 배열명 = new Array(3); => 3개의 요소를 가진 배열 생성

  - 배열 요소 접근 방법
    - 배열명[인덱스] = 요소값
    - 배열명.length = 배열의 길이

  - 배열 메소드
    - 배열명.push(요소) = 배열의 끝에 요소 추가
    - 배열명.pop() = 배열의 끝 요소 제거
    - 배열명.shift() = 배열의 첫 요소 제거
    등등

  - 스프레드 연산자 = 배열을 복사하거나 합칠 때 사용
    - let arr1 = [1, 2, 3];
      let arr2 = [...arr1]; => arr1을 복사하여 arr2에 저장
      let arr3 = [...arr1, 4, 5]; => arr1에 4, 5를 추가하여 arr3에 저장


객체(327)
  - 객체 선언 방법
    - 키워드 객체명 = {키:값, 키:값, 키:값};
    - 키워드 객체명 = new Object(); => 빈 객체 생성












함수(325)
  - 함수 선언 방법
    - 함수 선언식 = function 함수명(매개변수) {함수 내용}
    - 함수 표현식 = var 함수명 = function(매개변수) {함수 내용}
    - 화살표 함수 = var 함수명 = (매개변수) => {함수 내용}

  - 함수 선언식 (Function Declarations)
    일반적인 프로그래밍 코드에서 사용하는 함수 선언방식.
    
    function foo() {
    return "이것은 함수입니다.";
    }
    
  - 함수 표현식 (Function Expressions)
    자바스크립트 함수는 표현식을 사용하여 정의 될 수 있으며, 함수 표현식은 변수로 저장될수 있다.
    
    e.g. ) `var x = function (a, b) {return a * b};`
    
    함수 표현식이 변수에 저장되면, 변수는 함수처럼 사용 가능해진다.
    변수에 저장된 함수는 함수명이 필요 없으며, 변수 이름을 통하여 호출된다.
    
    함수 선언식은 코드가 실행되기 전에 로드되지만, 함수 표현식은 인터프리터가 해당 코드 줄에 도달 할 때만 로드된다.


함수 선언 방법
  - 함수 선언식 = function 함수명(매개변수) {함수 내용}
  - 함수 표현식 = var 함수명 = function(매개변수) {함수 내용}
  - 화살표 함수 = var 함수명 = (매개변수) => {함수 내용}



  함수 선언식 (Function Declarations)
  일반적인 프로그래밍 코드에서 사용하는 함수 선언방식.
  
  function foo() {
  return "이것은 함수입니다.";
  }
  
  함수 표현식 (Function Expressions)
  자바스크립트 함수는 표현식을 사용하여 정의 될 수 있으며, 함수 표현식은 변수로 저장될수 있다.
  
  e.g. ) `var x = function (a, b) {return a * b};`
  
  함수 표현식이 변수에 저장되면, 변수는 함수처럼 사용 가능해진다.
  변수에 저장된 함수는 함수명이 필요 없으며, 변수 이름을 통하여 호출된다.
  
  함수 선언식은 코드가 실행되기 전에 로드되지만, 함수 표현식은 인터프리터가 해당 코드 줄에 도달 할 때만 로드된다. -->